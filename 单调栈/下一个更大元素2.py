"""
coding: utf8
@time: 2021/3/6 22:29
@author: cjr
@file: 下一个更大元素2.py

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺
序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:

输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数；
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
注意: 输入数组的长度不会超过 10000。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-greater-element-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""
from typing import List


class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        """
        一个循环数组的小技巧就是直接取模，就可以让数组循环起来。
        比如数组[5, 4, 3, 7]的长度是4，那么循环数组是[5, 4, 3, 7, 5, 4, 3, 7]
        第五个数时候就是4 % 4 == 0 下标0对应的值是5
        第六个数时候就是5 % 4 == 1 下标1对应的值就是4
        这样就让数组循环了起来。
        :param nums:
        :return:
        """
        n = len(nums)
        res = [-1] * n
        # 栈中要保存元素下标
        stack = []
        # 因为是循环数组，所以要循环2次哦
        for i in range(n * 2):
            # 注意！！！下面一句话是单调栈实现关键句！！！
            # 当栈不为空，并且栈中的最后一个元素比当前元素还小时候，
            # 说明当前元素是比所有栈中元素都大的，因为我们维护的栈是单调递增栈
            # 此时栈中的最后一个元素就没有用了，pop出去。因为我们已经有一个比它更大的元素。
            # 看一个例子： [5, 4, 3, 7]
            # 当遍历7的时候，7比栈的最后一个元素3要大，所以后面的元素的更大的数只能是7不可能是3，
            # 所以弹出去3就可以。然后3这个位置上下一个最大的数就是当前数了。
            while stack and nums[stack[-1]] < nums[i % n]:
                res[stack.pop()] = nums[i % n]
            stack.append(i % n)
        return res







