"""
coding: utf8
@time: 2021/3/4 23:21
@author: cjr
@file: 俄罗斯套娃信封问题.py
题目链接：https://leetcode-cn.com/problems/russian-doll-envelopes/
"""
from typing import List


class Solution:
    """
    思路：给出的是一个二维结构，只有当元素的两个值都小于另外一个元素的两个值时候才可以套娃。
    比较容易想到的解法是按照元素的两个值递增排列。但是这样需要处理的一个问题就是可能会出现第二个递增但是第一个相等的情况
    或者第一个递增，第二个相等的情况。
    所以我们先按照第一个数排序，这样第一个数有了顺序，如果第一个数相等怎么办呢？
    我们再按照第二个数的降序排序，这样就可以保证第二个数最大的在最前面，然后遍历到这个数时候，发现不是递增，就会停止。
    举个例子说明：
    原数组： [[5,4],[6,4],[6,7],[2,3]]
    先对第一个数升序： [[2, 3], [5, 4], [6, 5], [6, 7]]，此时看第二个数的话3,4,5,7,就会得出4的错误结果，
    因为第三个元素的第一个数和第四个元素的第一个数相等，所以不能套娃。这时候我们只要在后两个相等的元素中对第二个数降序排序，
    得到 [[2, 3], [5, 4], [6, 7], [6, 5]] 这样我们只看第二个数的结果就是3,4,7，会得出3的正确结果。
    剩下的就是 严格最长递增子序列的问题。
    所以总结下步骤：
    1、对第一个数按升序排序后，对第一个数相同的做降序排序。
    2、然后只需要看第二个数即可，对整体做 严格最长递增子序列的 解法。
    """
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        n = len(envelopes)
        envelopes.sort(key=lambda x: (x[0], -x[1]))
        # 因为每个元素至少是他本身，所以动态规划数组初始化为1
        # 动态规划数组f[i]的含义即是到i位置最长的严格上升子序列长度！！！
        f = [1] * n
        for i in range(n):
            for j in range(i):
                if envelopes[j][1] < envelopes[i][1]:
                    f[i] = max(f[j] + 1, f[i])
        return max(f)






